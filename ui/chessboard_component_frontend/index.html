<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chessboard Component</title>
    <style>
      :root {
        --light: #f0d9b5;
        --dark: #b58863;
        --legal: rgba(59, 130, 246, 0.35);
        --selected: rgba(34, 197, 94, 0.35);
        --correct: rgba(34, 197, 94, 0.55);
        --incorrect: rgba(239, 68, 68, 0.55);
        --viable: rgba(234, 179, 8, 0.55);
        --piece-white: #111827;
        --piece-black: #111827;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background: transparent;
      }

      .wrap {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 8px 0;
      }

      .board {
        display: grid;
        grid-template-columns: repeat(8, 52px);
        grid-template-rows: repeat(8, 52px);
        border-radius: 10px;
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
      }

      .sq {
        width: 52px;
        height: 52px;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
        touch-action: manipulation;
      }

      .sq.light {
        background: var(--light);
      }

      .sq.dark {
        background: var(--dark);
      }

      .sq.legal {
        /* Dot indicator is rendered via ::after */
      }

      .sq.selected {
        box-shadow: inset 0 0 0 4px var(--selected);
      }

      .sq.correct {
        box-shadow: inset 0 0 0 4px var(--correct);
      }

      .sq.incorrect {
        box-shadow: inset 0 0 0 4px var(--incorrect);
      }

      .sq.viable {
        box-shadow: inset 0 0 0 4px var(--viable);
      }

      .piece {
        width: 42px;
        height: 42px;
        cursor: grab;
        -webkit-user-drag: element;
        user-select: none;
        -webkit-user-select: none;
        touch-action: none;
      }

      .piece.dragging {
        opacity: 0.6;
        cursor: grabbing;
      }

      /* Legal move dot */
      .sq.legal::after {
        content: "";
        width: 14px;
        height: 14px;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.65);
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }

      /* If a piece is on the square, make the dot a subtle ring instead */
      .sq.legal.occupied::after {
        width: 34px;
        height: 34px;
        background: transparent;
        border: 4px solid rgba(59, 130, 246, 0.55);
      }

      .hint {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        color: rgba(0, 0, 0, 0.6);
        text-align: center;
        margin-top: 6px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div id="board" class="board" aria-label="Chessboard"></div>
    </div>
    <div id="hint" class="hint"></div>

    <script>
      // --- Streamlit Component Protocol (minimal) ---
      function _postMessage(message) {
        window.parent.postMessage(message, "*");
      }

      function setComponentValue(value) {
        _postMessage({
          isStreamlitMessage: true,
          type: "streamlit:setComponentValue",
          value: value,
        });
      }

      function setFrameHeight(height) {
        _postMessage({
          isStreamlitMessage: true,
          type: "streamlit:setFrameHeight",
          height: height,
        });
      }

      function componentReady() {
        _postMessage({
          isStreamlitMessage: true,
          type: "streamlit:componentReady",
          apiVersion: 1,
        });
      }

      // --- Chessboard Rendering ---
      const PIECES = {
        P: "P",
        N: "N",
        B: "B",
        R: "R",
        Q: "Q",
        K: "K",
        p: "p",
        n: "n",
        b: "b",
        r: "r",
        q: "q",
        k: "k",
      };

      // Original, locally-embedded SVG piece set (no external downloads/CDNs).
      function svgDataUri(svg) {
        // Encode as a safe data URI.
        const encoded = encodeURIComponent(svg)
          .replace(/%0A/g, "")
          .replace(/%20/g, " ");
        return `data:image/svg+xml;charset=utf-8,${encoded}`;
      }

      // Optional: user-provided piece assets.
      // If these files exist, we prefer them to match chess-site visuals.
      // Place files in: ui/chessboard_component_frontend/pieces/
      // Expected names: wK,wQ,wR,wB,wN,wP and bK,bQ,bR,bB,bN,bP (svg or png)
      function assetKeyFromPieceChar(pieceChar) {
        const kind = (pieceChar || "").toUpperCase();
        const color = pieceChar && pieceChar.toUpperCase() === pieceChar ? "w" : "b";
        return `${color}${kind}`;
      }

      function createPieceElement(pieceChar) {
        const key = assetKeyFromPieceChar(pieceChar);
        const kind = (pieceChar || "").toUpperCase();
        const pieceColor = pieceChar.toUpperCase() === pieceChar ? "w" : "b";

        const img = document.createElement("img");
        img.className = "piece";
        img.alt = key;

        // Try local assets first: svg -> png -> fallback to built-in SVG.
        let stage = 0;
        const trySrc = () => {
          stage += 1;
          if (stage === 1) img.src = `pieces/${key}.svg`;
          else if (stage === 2) img.src = `pieces/${key}.png`;
          else {
            const svg = pieceSvg(kind, pieceColor);
            img.src = svgDataUri(svg);
          }
        };
        img.onerror = () => trySrc();
        trySrc();

        return img;
      }

      function pieceSvg(kind, color) {
        // kind: P,N,B,R,Q,K ; color: 'w'|'b'
        const isWhite = color === "w";
        const baseFill = isWhite ? "#f8fafc" : "#111827";
        const shadeFill = isWhite ? "#e5e7eb" : "#0b1220";
        const stroke = isWhite ? "#111827" : "#0f172a";
        const s = 2;

        const defs = `
  <defs>
    <linearGradient id="g" x1="0" y1="0" x2="0" y2="1">
      <stop offset="0" stop-color="${baseFill}"/>
      <stop offset="1" stop-color="${shadeFill}"/>
    </linearGradient>
    <filter id="ds" x="-20%" y="-20%" width="140%" height="140%">
      <feDropShadow dx="0" dy="1.2" stdDeviation="1.2" flood-color="rgba(0,0,0,0.35)"/>
    </filter>
  </defs>`;

        const common = `fill="url(#g)" stroke="${stroke}" stroke-width="${s}" stroke-linecap="round" stroke-linejoin="round"`;
        const commonFlat = `fill="${baseFill}" stroke="${stroke}" stroke-width="${s}" stroke-linecap="round" stroke-linejoin="round"`;

        // These are original, Staunton-inspired silhouettes (not copied from chess.com/lichess).
        if (kind === "P") {
          return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  ${defs}
  <g filter="url(#ds)">
    <circle cx="32" cy="18" r="8" ${commonFlat}/>
    <path d="M24 28c0-4 3-7 8-7s8 3 8 7c0 3-1 5-2 7 5 3 9 8 9 14 0 5-4 9-9 9H26c-5 0-9-4-9-9 0-6 4-11 9-14-1-2-2-4-2-7z" ${common}/>
    <path d="M20 56h24" ${commonFlat}/>
  </g>
</svg>`;
        }

        if (kind === "N") {
          return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  ${defs}
  <g filter="url(#ds)">
    <path d="M22 54h26c3 0 6-2 6-6 0-10-6-16-12-22 2-2 4-4 6-6 3-3 2-8-2-10-3-2-7-1-9 2l-6 8c-5 6-7 11-7 18v6z" ${common}/>
    <path d="M28 28c2-6 7-11 14-14" ${commonFlat}/>
    <circle cx="40" cy="22" r="2.2" fill="${stroke}"/>
    <path d="M18 56h28" ${commonFlat}/>
  </g>
</svg>`;
        }

        if (kind === "B") {
          return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  ${defs}
  <g filter="url(#ds)">
    <path d="M32 10c-8 7-12 14-12 22 0 6 3 11 8 14-4 3-7 6-7 10 0 4 3 8 8 8h6c5 0 8-4 8-8 0-4-3-7-7-10 5-3 8-8 8-14 0-8-4-15-12-22z" ${common}/>
    <path d="M28 30l8 8" stroke="${stroke}" stroke-width="${s}" stroke-linecap="round"/>
    <path d="M20 56h24" ${commonFlat}/>
  </g>
</svg>`;
        }

        if (kind === "R") {
          return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  ${defs}
  <g filter="url(#ds)">
    <path d="M18 18h6v-8h6v8h4v-8h6v8h4v-8h6v8h6v12H18V18z" ${common}/>
    <path d="M22 30h20v18H22V30z" ${common}/>
    <path d="M18 50h28v8H18v-8z" ${common}/>
  </g>
</svg>`;
        }

        if (kind === "Q") {
          return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  ${defs}
  <g filter="url(#ds)">
    <circle cx="18" cy="18" r="4" ${commonFlat}/>
    <circle cx="32" cy="14" r="4" ${commonFlat}/>
    <circle cx="46" cy="18" r="4" ${commonFlat}/>
    <path d="M18 22l6 16h16l6-16" ${common}/>
    <path d="M22 38h20c5 0 10 5 10 11 0 6-5 11-11 11H23c-6 0-11-5-11-11 0-6 5-11 10-11z" ${common}/>
    <path d="M18 56h28" ${commonFlat}/>
  </g>
</svg>`;
        }

        // King
        return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  ${defs}
  <g filter="url(#ds)">
    <path d="M32 10v10" stroke="${stroke}" stroke-width="${s}" stroke-linecap="round"/>
    <path d="M27 15h10" stroke="${stroke}" stroke-width="${s}" stroke-linecap="round"/>
    <path d="M24 28c0-7 4-12 8-12s8 5 8 12c0 4-2 7-4 9 6 4 10 8 10 14 0 5-4 9-9 9H27c-5 0-9-4-9-9 0-6 4-10 10-14-2-2-4-5-4-9z" ${common}/>
    <path d="M18 56h28" ${commonFlat}/>
  </g>
</svg>`;

      }

      function parseFenPieces(fen) {
        // Returns map like {"e4": "P"}
        const parts = (fen || "").split(" ");
        const placement = parts[0] || "";
        const rows = placement.split("/");
        const out = {};
        if (rows.length !== 8) return out;

        for (let r = 0; r < 8; r++) {
          const row = rows[r];
          let file = 0;
          for (const ch of row) {
            if (ch >= "1" && ch <= "8") {
              file += parseInt(ch, 10);
            } else {
              const sq = String.fromCharCode("a".charCodeAt(0) + file) + (8 - r);
              out[sq] = ch;
              file += 1;
            }
          }
        }
        return out;
      }

      function squareColor(fileIdx, rankIdx) {
        return (fileIdx + rankIdx) % 2 === 0 ? "dark" : "light";
      }

      function uciFromSquares(fromSq, toSq, legalMoves) {
        const base = fromSq + toSq;
        // Prefer exact match.
        for (const m of legalMoves) {
          if (m === base) return m;
        }
        // Handle promotions (e7e8q etc)
        const candidates = legalMoves.filter((m) => m.startsWith(base));
        if (candidates.length === 0) return null;
        // Prefer queen promotion when ambiguous
        const q = candidates.find((m) => m.length === 5 && m.endsWith("q"));
        return q || candidates[0];
      }

      let args = {
        fen: chessStartFen(),
        orientation: "white",
        legal_moves: [],
        side_to_move: "w",
        highlights: {
          legal_to: [],
          selected: null,
          correct_squares: [],
          incorrect_squares: [],
          viable_squares: [],
        },
        ui: {
          hint: "",
        },
      };

      function chessStartFen() {
        return "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
      }

      let selectedSquare = null;

      function render() {
        const boardEl = document.getElementById("board");
        const hintEl = document.getElementById("hint");
        const pieces = parseFenPieces(args.fen);

        const orientation = args.orientation === "black" ? "black" : "white";
        const legalMoves = Array.isArray(args.legal_moves) ? args.legal_moves : [];
        const sideToMove = args.side_to_move === "b" ? "b" : "w";

        hintEl.textContent = (args.ui && args.ui.hint) || "";

        // Square iteration order based on orientation.
        const files = ["a", "b", "c", "d", "e", "f", "g", "h"];
        const ranks = [1, 2, 3, 4, 5, 6, 7, 8];
        const viewFiles = orientation === "white" ? files : [...files].reverse();
        const viewRanks = orientation === "white" ? [...ranks].reverse() : ranks;

        // Build destination highlight set for selectedSquare
        const legalDestinations = new Set();
        if (selectedSquare) {
          for (const m of legalMoves) {
            if (m && m.startsWith(selectedSquare) && m.length >= 4) {
              legalDestinations.add(m.slice(2, 4));
            }
          }
        }

        const correctSq = new Set((args.highlights && args.highlights.correct_squares) || []);
        const incorrectSq = new Set((args.highlights && args.highlights.incorrect_squares) || []);
        const viableSq = new Set((args.highlights && args.highlights.viable_squares) || []);

        boardEl.innerHTML = "";

        for (let rIdx = 0; rIdx < 8; rIdx++) {
          for (let fIdx = 0; fIdx < 8; fIdx++) {
            const file = viewFiles[fIdx];
            const rank = viewRanks[rIdx];
            const sq = file + String(rank);

            const sqEl = document.createElement("div");
            sqEl.className = `sq ${squareColor(
              // We want colors fixed to real board, not orientation.
              files.indexOf(file),
              ranks.indexOf(rank)
            )}`;
            sqEl.dataset.square = sq;

            if (selectedSquare === sq) sqEl.classList.add("selected");
            if (legalDestinations.has(sq)) sqEl.classList.add("legal");
            if (correctSq.has(sq)) sqEl.classList.add("correct");
            if (incorrectSq.has(sq)) sqEl.classList.add("incorrect");
            if (viableSq.has(sq)) sqEl.classList.add("viable");

            // Drop target logic
            sqEl.addEventListener("dragover", (e) => {
              if (!selectedSquare) return;
              if (!legalDestinations.has(sq)) return;
              e.preventDefault();
            });
            sqEl.addEventListener("drop", (e) => {
              e.preventDefault();
              if (!selectedSquare) return;
              const uci = uciFromSquares(selectedSquare, sq, legalMoves);
              if (!uci) return;
              // Clear selection BEFORE emitting to prevent stale state on rerender
              selectedSquare = null;
              setComponentValue(uci);
            });

            // Click-to-move
            sqEl.addEventListener("click", () => {
              const piece = pieces[sq] || null;
              const pieceColor = piece ? (piece.toUpperCase() === piece ? "w" : "b") : null;

              if (selectedSquare) {
                // Try to resolve a legal move even if highlights are stale.
                // (This makes click-to-move robust in embedded iframes.)
                const uci = uciFromSquares(selectedSquare, sq, legalMoves);
                if (uci) {
                  selectedSquare = null;
                  setComponentValue(uci);
                  return;
                }

                // Switch selection if clicking another own piece
                if (piece && pieceColor === sideToMove) {
                  selectedSquare = sq;
                  render();
                  return;
                }

                // Otherwise keep selection (prevents glitchy deselect on misclick)
                // User can deselect by clicking the selected square again.
                if (sq === selectedSquare) {
                  selectedSquare = null;
                }
                render();
                return;
              }

              // No selection yet: select if own piece
              if (piece && pieceColor === sideToMove) {
                selectedSquare = sq;
                render();
              }
            });

            const pieceChar = pieces[sq];
            if (pieceChar) {
              sqEl.classList.add("occupied");

              const pieceEl = createPieceElement(pieceChar);

              const pieceColor = pieceChar.toUpperCase() === pieceChar ? "w" : "b";

              const draggable = pieceColor === sideToMove;
              pieceEl.draggable = draggable;

              // Some browsers can swallow click events on draggable images.
              // Use a light tap detector to forward taps/clicks to the square click
              // handler so click-to-move works reliably (including captures) without
              // breaking drag-and-drop.
              let _tapStart = null;
              pieceEl.addEventListener("pointerdown", (e) => {
                // Only track primary button / primary touch.
                if (typeof e.button === "number" && e.button !== 0) return;
                _tapStart = { x: e.clientX, y: e.clientY };
              });
              pieceEl.addEventListener("pointercancel", () => {
                _tapStart = null;
              });
              pieceEl.addEventListener("pointerup", (e) => {
                if (!_tapStart) return;
                const dx = (e.clientX || 0) - _tapStart.x;
                const dy = (e.clientY || 0) - _tapStart.y;
                _tapStart = null;
                if (dx * dx + dy * dy > 25) return; // moved > ~5px => treat as drag
                e.preventDefault();
                e.stopPropagation();
                sqEl.click();
              });
              pieceEl.addEventListener("click", (e) => {
                e.preventDefault();
                e.stopPropagation();
                sqEl.click();
              });

              pieceEl.addEventListener("dragstart", (e) => {
                if (!draggable) {
                  e.preventDefault();
                  return;
                }
                selectedSquare = sq;
                pieceEl.classList.add("dragging");
                try {
                  e.dataTransfer.setData("text/plain", sq);
                } catch (_) {}
                render();
              });
              pieceEl.addEventListener("dragend", () => {
                pieceEl.classList.remove("dragging");
              });

              sqEl.appendChild(pieceEl);
            }

            boardEl.appendChild(sqEl);
          }
        }

        // Height: board + hint
        setFrameHeight(document.body.scrollHeight);
      }

      let lastFen = "";
      
      window.addEventListener("message", (event) => {
        const data = event.data;
        if (!data || data.type !== "streamlit:render") return;

        const newArgs = data.args || args;
        
        // Clear selection if the FEN (position) changed - this means the move was accepted
        // and we're seeing a new board state
        if (typeof newArgs.fen === "string" && newArgs.fen !== lastFen) {
          selectedSquare = null;
          lastFen = newArgs.fen;
        }
        
        args = newArgs;
        render();
      });

      componentReady();
      // Render a default board while waiting for Streamlit args
      render();
    </script>
  </body>
</html>
