<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Chessboard Component</title>
    <style>
      :root {
        --light: #f0d9b5;
        --dark: #b58863;
        --legal: rgba(59, 130, 246, 0.35);
        --selected: rgba(34, 197, 94, 0.35);
        --correct: rgba(34, 197, 94, 0.55);
        --incorrect: rgba(239, 68, 68, 0.55);
        --piece-white: #111827;
        --piece-black: #111827;
      }

      html,
      body {
        margin: 0;
        padding: 0;
        background: transparent;
      }

      .wrap {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 8px 0;
      }

      .board {
        display: grid;
        grid-template-columns: repeat(8, 52px);
        grid-template-rows: repeat(8, 52px);
        border-radius: 10px;
        overflow: hidden;
        user-select: none;
        -webkit-user-select: none;
      }

      .sq {
        width: 52px;
        height: 52px;
        display: flex;
        justify-content: center;
        align-items: center;
        position: relative;
      }

      .sq.light {
        background: var(--light);
      }

      .sq.dark {
        background: var(--dark);
      }

      .sq.legal {
        /* Dot indicator is rendered via ::after */
      }

      .sq.selected {
        box-shadow: inset 0 0 0 4px var(--selected);
      }

      .sq.correct {
        box-shadow: inset 0 0 0 4px var(--correct);
      }

      .sq.incorrect {
        box-shadow: inset 0 0 0 4px var(--incorrect);
      }

      .piece {
        width: 42px;
        height: 42px;
        cursor: grab;
        -webkit-user-drag: element;
        user-select: none;
        -webkit-user-select: none;
      }

      .piece.dragging {
        opacity: 0.6;
        cursor: grabbing;
      }

      /* Legal move dot */
      .sq.legal::after {
        content: "";
        width: 14px;
        height: 14px;
        border-radius: 999px;
        background: rgba(59, 130, 246, 0.65);
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
      }

      /* If a piece is on the square, make the dot a subtle ring instead */
      .sq.legal.occupied::after {
        width: 34px;
        height: 34px;
        background: transparent;
        border: 4px solid rgba(59, 130, 246, 0.55);
      }

      .hint {
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
        font-size: 12px;
        color: rgba(0, 0, 0, 0.6);
        text-align: center;
        margin-top: 6px;
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <div id="board" class="board" aria-label="Chessboard"></div>
    </div>
    <div id="hint" class="hint"></div>

    <script>
      // --- Streamlit Component Protocol (minimal) ---
      function _postMessage(message) {
        window.parent.postMessage(message, "*");
      }

      function setComponentValue(value) {
        _postMessage({
          isStreamlitMessage: true,
          type: "streamlit:setComponentValue",
          value: value,
        });
      }

      function setFrameHeight(height) {
        _postMessage({
          isStreamlitMessage: true,
          type: "streamlit:setFrameHeight",
          height: height,
        });
      }

      function componentReady() {
        _postMessage({
          isStreamlitMessage: true,
          type: "streamlit:componentReady",
          apiVersion: 1,
        });
      }

      // --- Chessboard Rendering ---
      const PIECES = {
        P: "P",
        N: "N",
        B: "B",
        R: "R",
        Q: "Q",
        K: "K",
        p: "p",
        n: "n",
        b: "b",
        r: "r",
        q: "q",
        k: "k",
      };

      // Original, locally-embedded SVG piece set (no external downloads/CDNs).
      function svgDataUri(svg) {
        // Encode as a safe data URI.
        const encoded = encodeURIComponent(svg)
          .replace(/%0A/g, "")
          .replace(/%20/g, " ");
        return `data:image/svg+xml;charset=utf-8,${encoded}`;
      }

      function pieceSvg(kind, color) {
        // kind: P,N,B,R,Q,K ; color: 'w'|'b'
        const fill = color === "w" ? "#f9fafb" : "#111827";
        const stroke = "#111827";
        const s = 2.2;
        const common = `fill=\"${fill}\" stroke=\"${stroke}\" stroke-width=\"${s}\" stroke-linecap=\"round\" stroke-linejoin=\"round\"`;

        // Each piece uses simple geometric shapes in a consistent style.
        if (kind === "P") {
          return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 64 64\">
  <circle cx=\"32\" cy=\"20\" r=\"10\" ${common}/>
  <path d=\"M22 52h20c6 0 10-4 10-9 0-8-6-13-12-18-2-2-3-4-3-7H27c0 3-1 5-3 7-6 5-12 10-12 18 0 5 4 9 10 9z\" ${common}/>
  <path d=\"M18 56h28\" ${common}/>
</svg>`;
        }

        if (kind === "N") {
          return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 64 64\">
  <path d=\"M18 54h28c2 0 4-2 4-4 0-10-6-16-12-22l6-6c2-2 2-5 0-7-2-2-5-2-7 0l-9 9c-3 3-5 6-5 12v7\" ${common}/>
  <path d=\"M25 30c2-6 7-11 13-14\" ${common}/>
  <circle cx=\"36\" cy=\"23\" r=\"2.4\" fill=\"${stroke}\"/>
  <path d=\"M16 56h32\" ${common}/>
</svg>`;
        }

        if (kind === "B") {
          return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 64 64\">
  <path d=\"M32 10c-7 6-11 12-11 19 0 5 3 9 7 12-4 3-7 6-7 10 0 4 3 7 7 7h8c4 0 7-3 7-7 0-4-3-7-7-10 4-3 7-7 7-12 0-7-4-13-11-19z\" ${common}/>
  <path d=\"M28 28l8 8\" stroke=\"${stroke}\" stroke-width=\"${s}\" stroke-linecap=\"round\"/>
  <path d=\"M18 56h28\" ${common}/>
</svg>`;
        }

        if (kind === "R") {
          return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 64 64\">
  <path d=\"M18 18h6v-8h8v8h6v-8h8v8h6v10H18V18z\" ${common}/>
  <path d=\"M22 28h20v18H22V28z\" ${common}/>
  <path d=\"M18 50h28v6H18v-6z\" ${common}/>
</svg>`;
        }

        if (kind === "Q") {
          return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 64 64\">
  <circle cx=\"16\" cy=\"18\" r=\"4\" ${common}/>
  <circle cx=\"32\" cy=\"14\" r=\"4\" ${common}/>
  <circle cx=\"48\" cy=\"18\" r=\"4\" ${common}/>
  <path d=\"M18 22l6 16h16l6-16\" ${common}/>
  <path d=\"M22 38h20c4 0 8 4 8 9 0 5-4 9-9 9H23c-5 0-9-4-9-9 0-5 4-9 8-9z\" ${common}/>
  <path d=\"M18 56h28\" ${common}/>
</svg>`;
        }

        // King
        return `<?xml version=\"1.0\" encoding=\"UTF-8\"?>
<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 64 64\">
  <path d=\"M32 10v10\" stroke=\"${stroke}\" stroke-width=\"${s}\" stroke-linecap=\"round\"/>
  <path d=\"M27 15h10\" stroke=\"${stroke}\" stroke-width=\"${s}\" stroke-linecap=\"round\"/>
  <path d=\"M24 28c0-6 4-10 8-10s8 4 8 10c0 4-2 7-4 9 4 3 8 6 8 12 0 4-3 7-7 7H27c-4 0-7-3-7-7 0-6 4-9 8-12-2-2-4-5-4-9z\" ${common}/>
  <path d=\"M18 56h28\" ${common}/>
</svg>`;

      function parseFenPieces(fen) {
        // Returns map like {"e4": "P"}
        const parts = (fen || "").split(" ");
        const placement = parts[0] || "";
        const rows = placement.split("/");
        const out = {};
        if (rows.length !== 8) return out;

        for (let r = 0; r < 8; r++) {
          const row = rows[r];
          let file = 0;
          for (const ch of row) {
            if (ch >= "1" && ch <= "8") {
              file += parseInt(ch, 10);
            } else {
              const sq = String.fromCharCode("a".charCodeAt(0) + file) + (8 - r);
              out[sq] = ch;
              file += 1;
            }
          }
        }
        return out;
      }

      function squareColor(fileIdx, rankIdx) {
        return (fileIdx + rankIdx) % 2 === 0 ? "dark" : "light";
      }

      function uciFromSquares(fromSq, toSq, legalMoves) {
        const base = fromSq + toSq;
        // Prefer exact match.
        for (const m of legalMoves) {
          if (m === base) return m;
        }
        // Handle promotions (e7e8q etc)
        const candidates = legalMoves.filter((m) => m.startsWith(base));
        if (candidates.length === 0) return null;
        // Prefer queen promotion when ambiguous
        const q = candidates.find((m) => m.length === 5 && m.endsWith("q"));
        return q || candidates[0];
      }

      let args = {
        fen: chessStartFen(),
        orientation: "white",
        legal_moves: [],
        side_to_move: "w",
        highlights: {
          legal_to: [],
          selected: null,
          correct_squares: [],
          incorrect_squares: [],
        },
        ui: {
          hint: "",
        },
      };

      function chessStartFen() {
        return "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
      }

      let selectedSquare = null;

      function render() {
        const boardEl = document.getElementById("board");
        const hintEl = document.getElementById("hint");
        const pieces = parseFenPieces(args.fen);

        const orientation = args.orientation === "black" ? "black" : "white";
        const legalMoves = Array.isArray(args.legal_moves) ? args.legal_moves : [];
        const sideToMove = args.side_to_move === "b" ? "b" : "w";

        hintEl.textContent = (args.ui && args.ui.hint) || "";

        // Square iteration order based on orientation.
        const files = ["a", "b", "c", "d", "e", "f", "g", "h"];
        const ranks = [1, 2, 3, 4, 5, 6, 7, 8];
        const viewFiles = orientation === "white" ? files : [...files].reverse();
        const viewRanks = orientation === "white" ? [...ranks].reverse() : ranks;

        // Build destination highlight set for selectedSquare
        const legalDestinations = new Set();
        if (selectedSquare) {
          for (const m of legalMoves) {
            if (m && m.startsWith(selectedSquare) && m.length >= 4) {
              legalDestinations.add(m.slice(2, 4));
            }
          }
        }

        const correctSq = new Set((args.highlights && args.highlights.correct_squares) || []);
        const incorrectSq = new Set((args.highlights && args.highlights.incorrect_squares) || []);

        boardEl.innerHTML = "";

        for (let rIdx = 0; rIdx < 8; rIdx++) {
          for (let fIdx = 0; fIdx < 8; fIdx++) {
            const file = viewFiles[fIdx];
            const rank = viewRanks[rIdx];
            const sq = file + String(rank);

            const sqEl = document.createElement("div");
            sqEl.className = `sq ${squareColor(
              // We want colors fixed to real board, not orientation.
              files.indexOf(file),
              ranks.indexOf(rank)
            )}`;
            sqEl.dataset.square = sq;

            if (selectedSquare === sq) sqEl.classList.add("selected");
            if (legalDestinations.has(sq)) sqEl.classList.add("legal");
            if (correctSq.has(sq)) sqEl.classList.add("correct");
            if (incorrectSq.has(sq)) sqEl.classList.add("incorrect");

            // Drop target logic
            sqEl.addEventListener("dragover", (e) => {
              if (!selectedSquare) return;
              if (!legalDestinations.has(sq)) return;
              e.preventDefault();
            });
            sqEl.addEventListener("drop", (e) => {
              e.preventDefault();
              if (!selectedSquare) return;
              const uci = uciFromSquares(selectedSquare, sq, legalMoves);
              if (!uci) return;
              setComponentValue({ uci });
            });

            // Click-to-move
            sqEl.addEventListener("click", () => {
              const piece = pieces[sq] || null;
              const pieceColor = piece ? (piece.toUpperCase() === piece ? "w" : "b") : null;

              if (selectedSquare) {
                // If clicking a legal destination, emit move
                if (legalDestinations.has(sq)) {
                  const uci = uciFromSquares(selectedSquare, sq, legalMoves);
                  if (uci) {
                    setComponentValue({ uci });
                  }
                  return;
                }

                // Switch selection if clicking another own piece
                if (piece && pieceColor === sideToMove) {
                  selectedSquare = sq;
                  render();
                  return;
                }

                // Otherwise clear selection
                selectedSquare = null;
                render();
                return;
              }

              // No selection yet: select if own piece
              if (piece && pieceColor === sideToMove) {
                selectedSquare = sq;
                render();
              }
            });

            const pieceChar = pieces[sq];
            if (pieceChar) {
              sqEl.classList.add("occupied");

              const pieceEl = document.createElement("img");
              pieceEl.className = "piece";

              const kind = (pieceChar || "").toUpperCase();
              const pieceColor = pieceChar.toUpperCase() === pieceChar ? "w" : "b";
              const svg = pieceSvg(kind, pieceColor);
              pieceEl.src = svgDataUri(svg);
              pieceEl.alt = `${pieceColor}${kind}`;

              const draggable = pieceColor === sideToMove;
              pieceEl.draggable = draggable;

              pieceEl.addEventListener("dragstart", (e) => {
                if (!draggable) {
                  e.preventDefault();
                  return;
                }
                selectedSquare = sq;
                pieceEl.classList.add("dragging");
                try {
                  e.dataTransfer.setData("text/plain", sq);
                } catch (_) {}
                render();
              });
              pieceEl.addEventListener("dragend", () => {
                pieceEl.classList.remove("dragging");
              });

              sqEl.appendChild(pieceEl);
            }

            boardEl.appendChild(sqEl);
          }
        }

        // Height: board + hint
        setFrameHeight(document.body.scrollHeight);
      }

      window.addEventListener("message", (event) => {
        const data = event.data;
        if (!data || data.type !== "streamlit:render") return;

        args = data.args || args;
        // Reset selection if the underlying position changed (prevents stale selections)
        if (typeof args.fen === "string") {
          // keep selection; selection is recalculated against legal_moves
        }
        render();
      });

      componentReady();
      // Render a default board while waiting for Streamlit args
      render();
    </script>
  </body>
</html>
